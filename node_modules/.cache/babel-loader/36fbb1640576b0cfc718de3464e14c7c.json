{"ast":null,"code":"/* eslint-disable no-plusplus */\n'use strict';\n\nvar levels = require('./levels');\n\nvar DEFAULT_FORMAT = ':remote-addr - -' + ' \":method :url HTTP/:http-version\"' + ' :status :content-length \":referrer\"' + ' \":user-agent\"';\n/**\n * Return request url path,\n * adding this function prevents the Cyclomatic Complexity,\n * for the assemble_tokens function at low, to pass the tests.\n *\n * @param  {IncomingMessage} req\n * @return {String}\n * @api private\n */\n\nfunction getUrl(req) {\n  return req.originalUrl || req.url;\n}\n/**\n   * Adds custom {token, replacement} objects to defaults,\n   * overwriting the defaults if any tokens clash\n   *\n   * @param  {IncomingMessage} req\n   * @param  {ServerResponse} res\n   * @param  {Array} customTokens\n   *    [{ token: string-or-regexp, replacement: string-or-replace-function }]\n   * @return {Array}\n   */\n\n\nfunction assembleTokens(req, res, customTokens) {\n  var arrayUniqueTokens = function arrayUniqueTokens(array) {\n    var a = array.concat();\n\n    for (var i = 0; i < a.length; ++i) {\n      for (var j = i + 1; j < a.length; ++j) {\n        // not === because token can be regexp object\n\n        /* eslint eqeqeq:0 */\n        if (a[i].token == a[j].token) {\n          a.splice(j--, 1);\n        }\n      }\n    }\n\n    return a;\n  };\n\n  var defaultTokens = [];\n  defaultTokens.push({\n    token: ':url',\n    replacement: getUrl(req)\n  });\n  defaultTokens.push({\n    token: ':protocol',\n    replacement: req.protocol\n  });\n  defaultTokens.push({\n    token: ':hostname',\n    replacement: req.hostname\n  });\n  defaultTokens.push({\n    token: ':method',\n    replacement: req.method\n  });\n  defaultTokens.push({\n    token: ':status',\n    replacement: res.__statusCode || res.statusCode\n  });\n  defaultTokens.push({\n    token: ':response-time',\n    replacement: res.responseTime\n  });\n  defaultTokens.push({\n    token: ':date',\n    replacement: new Date().toUTCString()\n  });\n  defaultTokens.push({\n    token: ':referrer',\n    replacement: req.headers.referer || req.headers.referrer || ''\n  });\n  defaultTokens.push({\n    token: ':http-version',\n    replacement: \"\".concat(req.httpVersionMajor, \".\").concat(req.httpVersionMinor)\n  });\n  defaultTokens.push({\n    token: ':remote-addr',\n    replacement: req.headers['x-forwarded-for'] || req.ip || req._remoteAddress || req.socket && (req.socket.remoteAddress || req.socket.socket && req.socket.socket.remoteAddress)\n  });\n  defaultTokens.push({\n    token: ':user-agent',\n    replacement: req.headers['user-agent']\n  });\n  defaultTokens.push({\n    token: ':content-length',\n    replacement: res._headers && res._headers['content-length'] || res.__headers && res.__headers['Content-Length'] || '-'\n  });\n  defaultTokens.push({\n    token: /:req\\[([^\\]]+)]/g,\n    replacement: function replacement(_, field) {\n      return req.headers[field.toLowerCase()];\n    }\n  });\n  defaultTokens.push({\n    token: /:res\\[([^\\]]+)]/g,\n    replacement: function replacement(_, field) {\n      return res._headers ? res._headers[field.toLowerCase()] || res.__headers[field] : res.__headers && res.__headers[field];\n    }\n  });\n  return arrayUniqueTokens(customTokens.concat(defaultTokens));\n}\n/**\n   * Return formatted log line.\n   *\n   * @param  {String} str\n   * @param {Array} tokens\n   * @return {String}\n   * @api private\n   */\n\n\nfunction format(str, tokens) {\n  for (var i = 0; i < tokens.length; i++) {\n    str = str.replace(tokens[i].token, tokens[i].replacement);\n  }\n\n  return str;\n}\n/**\n   * Return RegExp Object about nolog\n   *\n   * @param  {String|Array} nolog\n   * @return {RegExp}\n   * @api private\n   *\n   * syntax\n   *  1. String\n   *   1.1 \"\\\\.gif\"\n   *         NOT LOGGING http://example.com/hoge.gif and http://example.com/hoge.gif?fuga\n   *         LOGGING http://example.com/hoge.agif\n   *   1.2 in \"\\\\.gif|\\\\.jpg$\"\n   *         NOT LOGGING http://example.com/hoge.gif and\n   *           http://example.com/hoge.gif?fuga and http://example.com/hoge.jpg?fuga\n   *         LOGGING http://example.com/hoge.agif,\n   *           http://example.com/hoge.ajpg and http://example.com/hoge.jpg?hoge\n   *   1.3 in \"\\\\.(gif|jpe?g|png)$\"\n   *         NOT LOGGING http://example.com/hoge.gif and http://example.com/hoge.jpeg\n   *         LOGGING http://example.com/hoge.gif?uid=2 and http://example.com/hoge.jpg?pid=3\n   *  2. RegExp\n   *   2.1 in /\\.(gif|jpe?g|png)$/\n   *         SAME AS 1.3\n   *  3. Array\n   *   3.1 [\"\\\\.jpg$\", \"\\\\.png\", \"\\\\.gif\"]\n   *         SAME AS \"\\\\.jpg|\\\\.png|\\\\.gif\"\n   */\n\n\nfunction createNoLogCondition(nolog) {\n  var regexp = null;\n\n  if (nolog) {\n    if (nolog instanceof RegExp) {\n      regexp = nolog;\n    }\n\n    if (typeof nolog === 'string') {\n      regexp = new RegExp(nolog);\n    }\n\n    if (Array.isArray(nolog)) {\n      // convert to strings\n      var regexpsAsStrings = nolog.map(function (reg) {\n        return reg.source ? reg.source : reg;\n      });\n      regexp = new RegExp(regexpsAsStrings.join('|'));\n    }\n  }\n\n  return regexp;\n}\n/**\n   * Allows users to define rules around status codes to assign them to a specific\n   * logging level.\n   * There are two types of rules:\n   *   - RANGE: matches a code within a certain range\n   *     E.g. { 'from': 200, 'to': 299, 'level': 'info' }\n   *   - CONTAINS: matches a code to a set of expected codes\n   *     E.g. { 'codes': [200, 203], 'level': 'debug' }\n   * Note*: Rules are respected only in order of prescendence.\n   *\n   * @param {Number} statusCode\n   * @param {Level} currentLevel\n   * @param {Object} ruleSet\n   * @return {Level}\n   * @api private\n   */\n\n\nfunction matchRules(statusCode, currentLevel, ruleSet) {\n  var level = currentLevel;\n\n  if (ruleSet) {\n    var matchedRule = ruleSet.find(function (rule) {\n      var ruleMatched = false;\n\n      if (rule.from && rule.to) {\n        ruleMatched = statusCode >= rule.from && statusCode <= rule.to;\n      } else if (rule.codes) {\n        ruleMatched = rule.codes.indexOf(statusCode) !== -1;\n      }\n\n      return ruleMatched;\n    });\n\n    if (matchedRule) {\n      level = levels.getLevel(matchedRule.level, level);\n    }\n  }\n\n  return level;\n}\n/**\n   * Log requests with the given `options` or a `format` string.\n   *\n   * Options:\n   *\n   *   - `format`        Format string, see below for tokens\n   *   - `level`         A log4js levels instance. Supports also 'auto'\n   *   - `nolog`         A string or RegExp to exclude target logs\n   *   - `statusRules`   A array of rules for setting specific logging levels base on status codes\n   *\n   * Tokens:\n   *\n   *   - `:req[header]` ex: `:req[Accept]`\n   *   - `:res[header]` ex: `:res[Content-Length]`\n   *   - `:http-version`\n   *   - `:response-time`\n   *   - `:remote-addr`\n   *   - `:date`\n   *   - `:method`\n   *   - `:url`\n   *   - `:referrer`\n   *   - `:user-agent`\n   *   - `:status`\n   *\n   * @return {Function}\n   * @param logger4js\n   * @param options\n   * @api public\n   */\n\n\nmodule.exports = function getLogger(logger4js, options) {\n  /* eslint no-underscore-dangle:0 */\n  if (typeof options === 'object') {\n    options = options || {};\n  } else if (options) {\n    options = {\n      format: options\n    };\n  } else {\n    options = {};\n  }\n\n  var thisLogger = logger4js;\n  var level = levels.getLevel(options.level, levels.INFO);\n  var fmt = options.format || DEFAULT_FORMAT;\n  var nolog = options.nolog ? createNoLogCondition(options.nolog) : null;\n  return function (req, res, next) {\n    // mount safety\n    if (req._logging) return next(); // nologs\n\n    if (nolog && nolog.test(req.originalUrl)) return next();\n\n    if (thisLogger.isLevelEnabled(level) || options.level === 'auto') {\n      var start = new Date();\n      var writeHead = res.writeHead; // flag as logging\n\n      req._logging = true; // proxy for statusCode.\n\n      res.writeHead = function (code, headers) {\n        res.writeHead = writeHead;\n        res.writeHead(code, headers);\n        res.__statusCode = code;\n        res.__headers = headers || {}; // status code response level handling\n\n        if (options.level === 'auto') {\n          level = levels.INFO;\n          if (code >= 300) level = levels.WARN;\n          if (code >= 400) level = levels.ERROR;\n        } else {\n          level = levels.getLevel(options.level, levels.INFO);\n        }\n\n        level = matchRules(code, level, options.statusRules);\n      }; // hook on end request to emit the log entry of the HTTP request.\n\n\n      res.on('finish', function () {\n        res.responseTime = new Date() - start; // status code response level handling\n\n        if (res.statusCode && options.level === 'auto') {\n          level = levels.INFO;\n          if (res.statusCode >= 300) level = levels.WARN;\n          if (res.statusCode >= 400) level = levels.ERROR;\n        }\n\n        level = matchRules(res.statusCode, level, options.statusRules);\n\n        if (thisLogger.isLevelEnabled(level)) {\n          var combinedTokens = assembleTokens(req, res, options.tokens || []);\n\n          if (typeof fmt === 'function') {\n            var line = fmt(req, res, function (str) {\n              return format(str, combinedTokens);\n            });\n            if (line) thisLogger.log(level, line);\n          } else {\n            thisLogger.log(level, format(fmt, combinedTokens));\n          }\n        }\n      });\n    } // ensure next gets always called\n\n\n    return next();\n  };\n};","map":null,"metadata":{},"sourceType":"script"}