{"ast":null,"code":"var _toConsumableArray = require(\"d:\\\\Users\\\\c05917\\\\Desktop\\\\redux\\\\chrome-api\\\\chrome\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\n/** Wrap an API that uses callbacks with Promises\r\n * This expects the pattern function withCallback(arg1, arg2, ... argN, callback)\r\n * @author Keith Henry <keith.henry@evolutionjobs.co.uk>\r\n * @license MIT */\n(function () {\n  'use strict';\n  /** Wrap a function with a callback with a Promise.\r\n   * @param {function} f The function to wrap, should be pattern: withCallback(arg1, arg2, ... argN, callback).\r\n   * @param {function} parseCB Optional function to parse multiple callback parameters into a single object.\r\n   * @returns {Promise} Promise that resolves when the callback fires. */\n\n  function promisify(f, parseCB) {\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var safeArgs = args;\n      var callback; // The Chrome API functions all use arguments, so we can't use f.length to check\n      // If there is a last arg\n\n      if (args && args.length > 0) {\n        // ... and the last arg is a function\n        var last = args[args.length - 1];\n\n        if (typeof last === 'function') {\n          // Trim the last callback arg if it's been passed\n          safeArgs = args.slice(0, args.length - 1);\n          callback = last;\n        }\n      } // Return a promise\n\n\n      return new Promise(function (resolve, reject) {\n        try {\n          // Try to run the original function, with the trimmed args list\n          f.apply(void 0, _toConsumableArray(safeArgs).concat([function () {\n            for (var _len2 = arguments.length, cbArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              cbArgs[_key2] = arguments[_key2];\n            }\n\n            // If a callback was passed at the end of the original arguments\n            if (callback) {\n              // Don't allow a bug in the callback to stop the promise resolving\n              try {\n                callback.apply(void 0, cbArgs);\n              } catch (cbErr) {\n                reject(cbErr);\n              }\n            } // Chrome extensions always fire the callback, but populate chrome.runtime.lastError with exception details\n\n\n            if (chrome.runtime.lastError) // Return as an error for the awaited catch block\n              reject(new Error(chrome.runtime.lastError.message || \"Error thrown by API \".concat(chrome.runtime.lastError)));else {\n              if (parseCB) {\n                var cbObj = parseCB.apply(void 0, cbArgs);\n                resolve(cbObj);\n              } else if (!cbArgs || cbArgs.length === 0) resolve();else if (cbArgs.length === 1) resolve(cbArgs[0]);else resolve(cbArgs);\n            }\n          }]));\n        } catch (err) {\n          reject(err);\n        }\n      });\n    };\n  }\n  /** Promisify all the known functions in the map \r\n   * @param {object} api The Chrome native API to extend\r\n   * @param {Array} apiMap Collection of sub-API and functions to promisify */\n\n\n  function applyMap(api, apiMap) {\n    if (!api) // Not supported by current permissions\n      return;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = apiMap[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var funcDef = _step.value;\n        var funcName = void 0;\n        if (typeof funcDef === 'string') funcName = funcDef;else {\n          funcName = funcDef.n;\n        }\n        if (!api.hasOwnProperty(funcName)) // Member not in API\n          continue;\n        var m = api[funcName];\n        if (typeof m === 'function') // This is a function, wrap in a promise\n          api[funcName] = promisify(m, funcDef.cb);else // Sub-API, recurse this func with the mapped props\n          applyMap(m, funcDef.props);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n  /** Apply promise-maps to the Chrome native API.\r\n   * @param {object} apiMaps The API to apply. */\n\n\n  function applyMaps(apiMaps) {\n    for (var apiName in apiMaps) {\n      var callbackApi = chrome[apiName];\n      if (!callbackApi) // Not supported by current permissions\n        continue;\n      var apiMap = apiMaps[apiName];\n      applyMap(callbackApi, apiMap);\n    }\n  } // accessibilityFeatures https://developer.chrome.com/extensions/accessibilityFeatures\n\n\n  var knownA11ySetting = ['get', 'set', 'clear']; // ContentSetting https://developer.chrome.com/extensions/contentSettings#type-ContentSetting\n\n  var knownInContentSetting = ['clear', 'get', 'set', 'getResourceIdentifiers']; // StorageArea https://developer.chrome.com/extensions/storage#type-StorageArea\n\n  var knownInStorageArea = ['get', 'getBytesInUse', 'set', 'remove', 'clear'];\n  /** Map of API functions that follow the callback pattern that we can 'promisify' */\n\n  applyMaps({\n    accessibilityFeatures: [// Todo: this should extend AccessibilityFeaturesSetting.prototype instead\n    {\n      n: 'spokenFeedback',\n      props: knownA11ySetting\n    }, {\n      n: 'largeCursor',\n      props: knownA11ySetting\n    }, {\n      n: 'stickyKeys',\n      props: knownA11ySetting\n    }, {\n      n: 'highContrast',\n      props: knownA11ySetting\n    }, {\n      n: 'screenMagnifier',\n      props: knownA11ySetting\n    }, {\n      n: 'autoclick',\n      props: knownA11ySetting\n    }, {\n      n: 'virtualKeyboard',\n      props: knownA11ySetting\n    }, {\n      n: 'animationPolicy',\n      props: knownA11ySetting\n    }],\n    alarms: ['get', 'getAll', 'clear', 'clearAll'],\n    bookmarks: ['get', 'getChildren', 'getRecent', 'getTree', 'getSubTree', 'search', 'create', 'move', 'update', 'remove', 'removeTree'],\n    browser: ['openTab'],\n    browserAction: ['getTitle', 'setIcon', 'getPopup', 'getBadgeText', 'getBadgeBackgroundColor'],\n    browsingData: ['settings', 'remove', 'removeAppcache', 'removeCache', 'removeCookies', 'removeDownloads', 'removeFileSystems', 'removeFormData', 'removeHistory', 'removeIndexedDB', 'removeLocalStorage', 'removePluginData', 'removePasswords', 'removeWebSQL'],\n    commands: ['getAll'],\n    contentSettings: [// Todo: this should extend ContentSetting.prototype instead\n    {\n      n: 'cookies',\n      props: knownInContentSetting\n    }, {\n      n: 'images',\n      props: knownInContentSetting\n    }, {\n      n: 'javascript',\n      props: knownInContentSetting\n    }, {\n      n: 'location',\n      props: knownInContentSetting\n    }, {\n      n: 'plugins',\n      props: knownInContentSetting\n    }, {\n      n: 'popups',\n      props: knownInContentSetting\n    }, {\n      n: 'notifications',\n      props: knownInContentSetting\n    }, {\n      n: 'fullscreen',\n      props: knownInContentSetting\n    }, {\n      n: 'mouselock',\n      props: knownInContentSetting\n    }, {\n      n: 'microphone',\n      props: knownInContentSetting\n    }, {\n      n: 'camera',\n      props: knownInContentSetting\n    }, {\n      n: 'unsandboxedPlugins',\n      props: knownInContentSetting\n    }, {\n      n: 'automaticDownloads',\n      props: knownInContentSetting\n    }],\n    contextMenus: ['create', 'update', 'remove', 'removeAll'],\n    cookies: ['get', 'getAll', 'set', 'remove', 'getAllCookieStores'],\n    debugger: ['attach', 'detach', 'sendCommand', 'getTargets'],\n    desktopCapture: ['chooseDesktopMedia'],\n    // TODO: devtools.*\n    documentScan: ['scan'],\n    downloads: ['download', 'search', 'pause', 'resume', 'cancel', 'getFileIcon', 'erase', 'removeFile', 'acceptDanger'],\n    enterprise: [{\n      n: 'platformKeys',\n      props: ['getToken', 'getCertificates', 'importCertificate', 'removeCertificate']\n    }],\n    extension: ['isAllowedIncognitoAccess', 'isAllowedFileSchemeAccess'],\n    // mostly deprecated in favour of runtime\n    fileBrowserHandler: ['selectFile'],\n    fileSystemProvider: ['mount', 'unmount', 'getAll', 'get', 'notify'],\n    fontSettings: ['setDefaultFontSize', 'getFont', 'getDefaultFontSize', 'getMinimumFontSize', 'setMinimumFontSize', 'getDefaultFixedFontSize', 'clearDefaultFontSize', 'setDefaultFixedFontSize', 'clearFont', 'setFont', 'clearMinimumFontSize', 'getFontList', 'clearDefaultFixedFontSize'],\n    gcm: ['register', 'unregister', 'send'],\n    history: ['search', 'getVisits', 'addUrl', 'deleteUrl', 'deleteRange', 'deleteAll'],\n    i18n: ['getAcceptLanguages', 'detectLanguage'],\n    identity: ['getAuthToken', 'getProfileUserInfo', 'removeCachedAuthToken', 'launchWebAuthFlow', 'getRedirectURL'],\n    idle: ['queryState'],\n    input: [{\n      n: 'ime',\n      props: ['setMenuItems', 'commitText', 'setCandidates', 'setComposition', 'updateMenuItems', 'setCandidateWindowProperties', 'clearComposition', 'setCursorPosition', 'sendKeyEvents', 'deleteSurroundingText']\n    }],\n    management: ['setEnabled', 'getPermissionWarningsById', 'get', 'getAll', 'getPermissionWarningsByManifest', 'launchApp', 'uninstall', 'getSelf', 'uninstallSelf', 'createAppShortcut', 'setLaunchType', 'generateAppForLink'],\n    networking: [{\n      n: 'config',\n      props: ['setNetworkFilter', 'finishAuthentication']\n    }],\n    notifications: ['create', 'update', 'clear', 'getAll', 'getPermissionLevel'],\n    pageAction: ['getTitle', 'setIcon', 'getPopup'],\n    pageCapture: ['saveAsMHTML'],\n    permissions: ['getAll', 'contains', 'request', 'remove'],\n    platformKeys: ['selectClientCertificates', 'verifyTLSServerCertificate', {\n      n: \"getKeyPair\",\n      cb: function cb(publicKey, privateKey) {\n        return {\n          publicKey: publicKey,\n          privateKey: privateKey\n        };\n      }\n    }],\n    runtime: ['getBackgroundPage', 'openOptionsPage', 'setUninstallURL', 'restartAfterDelay', 'sendMessage', 'sendNativeMessage', 'getPlatformInfo', 'getPackageDirectoryEntry', {\n      n: \"requestUpdateCheck\",\n      cb: function cb(status, details) {\n        return {\n          status: status,\n          details: details\n        };\n      }\n    }],\n    scriptBadge: ['getPopup'],\n    sessions: ['getRecentlyClosed', 'getDevices', 'restore'],\n    storage: [// Todo: this should extend StorageArea.prototype instead\n    {\n      n: 'sync',\n      props: knownInStorageArea\n    }, {\n      n: 'local',\n      props: knownInStorageArea\n    }, {\n      n: 'managed',\n      props: knownInStorageArea\n    }],\n    socket: ['create', 'connect', 'bind', 'read', 'write', 'recvFrom', 'sendTo', 'listen', 'accept', 'setKeepAlive', 'setNoDelay', 'getInfo', 'getNetworkList'],\n    sockets: [{\n      n: 'tcp',\n      props: ['create', 'update', 'setPaused', 'setKeepAlive', 'setNoDelay', 'connect', 'disconnect', 'secure', 'send', 'close', 'getInfo', 'getSockets']\n    }, {\n      n: 'tcpServer',\n      props: ['create', 'update', 'setPaused', 'listen', 'disconnect', 'close', 'getInfo', 'getSockets']\n    }, {\n      n: 'udp',\n      props: ['create', 'update', 'setPaused', 'bind', 'send', 'close', 'getInfo', 'getSockets', 'joinGroup', 'leaveGroup', 'setMulticastTimeToLive', 'setMulticastLoopbackMode', 'getJoinedGroups', 'setBroadcast']\n    }],\n    system: [{\n      n: 'cpu',\n      props: ['getInfo']\n    }, {\n      n: 'memory',\n      props: ['getInfo']\n    }, {\n      n: 'storage',\n      props: ['getInfo', 'ejectDevice', 'getAvailableCapacity']\n    }],\n    tabCapture: ['capture', 'getCapturedTabs'],\n    tabs: ['get', 'getCurrent', 'sendMessage', 'create', 'duplicate', 'query', 'highlight', 'update', 'move', 'reload', 'remove', 'detectLanguage', 'captureVisibleTab', 'executeScript', 'insertCSS', 'setZoom', 'getZoom', 'setZoomSettings', 'getZoomSettings', 'discard'],\n    topSites: ['get'],\n    tts: ['isSpeaking', 'getVoices', 'speak'],\n    types: ['set', 'get', 'clear'],\n    vpnProvider: ['createConfig', 'destroyConfig', 'setParameters', 'sendPacket', 'notifyConnectionStateChanged'],\n    wallpaper: ['setWallpaper'],\n    webNavigation: ['getFrame', 'getAllFrames', 'handlerBehaviorChanged'],\n    windows: ['get', 'getCurrent', 'getLastFocused', 'getAll', 'create', 'update', 'remove']\n  });\n})();","map":null,"metadata":{},"sourceType":"script"}