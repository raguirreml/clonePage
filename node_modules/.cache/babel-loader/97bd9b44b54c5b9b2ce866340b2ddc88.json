{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"D:\\\\Users\\\\c05917\\\\Desktop\\\\redux\\\\chrome-api\\\\chrome\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar dateFormat = require('date-format');\n\nvar os = require('os');\n\nvar util = require('util');\n\nvar eol = os.EOL || '\\n';\nvar styles = {\n  // styles\n  bold: [1, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  // grayscale\n  white: [37, 39],\n  grey: [90, 39],\n  black: [90, 39],\n  // colors\n  blue: [34, 39],\n  cyan: [36, 39],\n  green: [32, 39],\n  magenta: [35, 39],\n  red: [91, 39],\n  yellow: [33, 39]\n};\n\nfunction colorizeStart(style) {\n  return style ? \"\\x1B[\".concat(styles[style][0], \"m\") : '';\n}\n\nfunction colorizeEnd(style) {\n  return style ? \"\\x1B[\".concat(styles[style][1], \"m\") : '';\n}\n/**\n * Taken from masylum's fork (https://github.com/masylum/log4js-node)\n */\n\n\nfunction colorize(str, style) {\n  return colorizeStart(style) + str + colorizeEnd(style);\n}\n\nfunction timestampLevelAndCategory(loggingEvent, colour) {\n  return colorize(util.format('[%s] [%s] %s - ', dateFormat.asString(loggingEvent.startTime), loggingEvent.level, loggingEvent.categoryName), colour);\n}\n/**\n * BasicLayout is a simple layout for storing the logs. The logs are stored\n * in following format:\n * <pre>\n * [startTime] [logLevel] categoryName - message\\n\n * </pre>\n *\n * @author Stephan Strittmatter\n */\n\n\nfunction basicLayout(loggingEvent) {\n  return timestampLevelAndCategory(loggingEvent) + util.format.apply(util, _toConsumableArray(loggingEvent.data));\n}\n/**\n * colouredLayout - taken from masylum's fork.\n * same as basicLayout, but with colours.\n */\n\n\nfunction colouredLayout(loggingEvent) {\n  return timestampLevelAndCategory(loggingEvent, loggingEvent.level.colour) + util.format.apply(util, _toConsumableArray(loggingEvent.data));\n}\n\nfunction messagePassThroughLayout(loggingEvent) {\n  return util.format.apply(util, _toConsumableArray(loggingEvent.data));\n}\n\nfunction dummyLayout(loggingEvent) {\n  return loggingEvent.data[0];\n}\n/**\n * PatternLayout\n * Format for specifiers is %[padding].[truncation][field]{[format]}\n * e.g. %5.10p - left pad the log level by 5 characters, up to a max of 10\n * Fields can be any of:\n *  - %r time in toLocaleTimeString format\n *  - %p log level\n *  - %c log category\n *  - %h hostname\n *  - %m log data\n *  - %d date in constious formats\n *  - %% %\n *  - %n newline\n *  - %z pid\n *  - %x{<tokenname>} add dynamic tokens to your log. Tokens are specified in the tokens parameter\n *  - %X{<tokenname>} add dynamic tokens to your log. Tokens are specified in logger context\n * You can use %[ and %] to define a colored block.\n *\n * Tokens are specified as simple key:value objects.\n * The key represents the token name whereas the value can be a string or function\n * which is called to extract the value to put in the log message. If token is not\n * found, it doesn't replace the field.\n *\n * A sample token would be: { 'pid' : function() { return process.pid; } }\n *\n * Takes a pattern string, array of tokens and returns a layout function.\n * @return {Function}\n * @param pattern\n * @param tokens\n * @param timezoneOffset\n *\n * @authors ['Stephan Strittmatter', 'Jan Schmidle']\n */\n\n\nfunction patternLayout(pattern, tokens) {\n  var TTCC_CONVERSION_PATTERN = '%r %p %c - %m%n';\n  var regex = /%(-?[0-9]+)?(\\.?[0-9]+)?([[\\]cdhmnprzxXy%])(\\{([^}]+)\\})?|([^%]+)/;\n  pattern = pattern || TTCC_CONVERSION_PATTERN;\n\n  function categoryName(loggingEvent, specifier) {\n    var loggerName = loggingEvent.categoryName;\n\n    if (specifier) {\n      var precision = parseInt(specifier, 10);\n      var loggerNameBits = loggerName.split('.');\n\n      if (precision < loggerNameBits.length) {\n        loggerName = loggerNameBits.slice(loggerNameBits.length - precision).join('.');\n      }\n    }\n\n    return loggerName;\n  }\n\n  function formatAsDate(loggingEvent, specifier) {\n    var format = dateFormat.ISO8601_FORMAT;\n\n    if (specifier) {\n      format = specifier; // Pick up special cases\n\n      if (format === 'ISO8601') {\n        format = dateFormat.ISO8601_FORMAT;\n      } else if (format === 'ISO8601_WITH_TZ_OFFSET') {\n        format = dateFormat.ISO8601_WITH_TZ_OFFSET_FORMAT;\n      } else if (format === 'ABSOLUTE') {\n        format = dateFormat.ABSOLUTETIME_FORMAT;\n      } else if (format === 'DATE') {\n        format = dateFormat.DATETIME_FORMAT;\n      }\n    } // Format the date\n\n\n    return dateFormat.asString(format, loggingEvent.startTime);\n  }\n\n  function hostname() {\n    return os.hostname().toString();\n  }\n\n  function formatMessage(loggingEvent) {\n    return util.format.apply(util, _toConsumableArray(loggingEvent.data));\n  }\n\n  function endOfLine() {\n    return eol;\n  }\n\n  function logLevel(loggingEvent) {\n    return loggingEvent.level.toString();\n  }\n\n  function startTime(loggingEvent) {\n    return dateFormat.asString('hh:mm:ss', loggingEvent.startTime);\n  }\n\n  function startColour(loggingEvent) {\n    return colorizeStart(loggingEvent.level.colour);\n  }\n\n  function endColour(loggingEvent) {\n    return colorizeEnd(loggingEvent.level.colour);\n  }\n\n  function percent() {\n    return '%';\n  }\n\n  function pid(loggingEvent) {\n    return loggingEvent && loggingEvent.pid ? loggingEvent.pid.toString() : process.pid.toString();\n  }\n\n  function clusterInfo() {\n    // this used to try to return the master and worker pids,\n    // but it would never have worked because master pid is not available to workers\n    // leaving this here to maintain compatibility for patterns\n    return pid();\n  }\n\n  function userDefined(loggingEvent, specifier) {\n    if (typeof tokens[specifier] !== 'undefined') {\n      return typeof tokens[specifier] === 'function' ? tokens[specifier](loggingEvent) : tokens[specifier];\n    }\n\n    return null;\n  }\n\n  function contextDefined(loggingEvent, specifier) {\n    var resolver = loggingEvent.context[specifier];\n\n    if (typeof resolver !== 'undefined') {\n      return typeof resolver === 'function' ? resolver(loggingEvent) : resolver;\n    }\n\n    return null;\n  }\n  /* eslint quote-props:0 */\n\n\n  var replacers = {\n    'c': categoryName,\n    'd': formatAsDate,\n    'h': hostname,\n    'm': formatMessage,\n    'n': endOfLine,\n    'p': logLevel,\n    'r': startTime,\n    '[': startColour,\n    ']': endColour,\n    'y': clusterInfo,\n    'z': pid,\n    '%': percent,\n    'x': userDefined,\n    'X': contextDefined\n  };\n\n  function replaceToken(conversionCharacter, loggingEvent, specifier) {\n    return replacers[conversionCharacter](loggingEvent, specifier);\n  }\n\n  function truncate(truncation, toTruncate) {\n    var len;\n\n    if (truncation) {\n      len = parseInt(truncation.substr(1), 10);\n      return toTruncate.substring(0, len);\n    }\n\n    return toTruncate;\n  }\n\n  function pad(padding, toPad) {\n    var len;\n\n    if (padding) {\n      if (padding.charAt(0) === '-') {\n        len = parseInt(padding.substr(1), 10); // Right pad with spaces\n\n        while (toPad.length < len) {\n          toPad += ' ';\n        }\n      } else {\n        len = parseInt(padding, 10); // Left pad with spaces\n\n        while (toPad.length < len) {\n          toPad = \" \".concat(toPad);\n        }\n      }\n    }\n\n    return toPad;\n  }\n\n  function truncateAndPad(toTruncAndPad, truncation, padding) {\n    var replacement = toTruncAndPad;\n    replacement = truncate(truncation, replacement);\n    replacement = pad(padding, replacement);\n    return replacement;\n  }\n\n  return function (loggingEvent) {\n    var formattedString = '';\n    var result;\n    var searchString = pattern;\n    /* eslint no-cond-assign:0 */\n\n    while ((result = regex.exec(searchString)) !== null) {\n      // const matchedString = result[0];\n      var padding = result[1];\n      var truncation = result[2];\n      var conversionCharacter = result[3];\n      var specifier = result[5];\n      var text = result[6]; // Check if the pattern matched was just normal text\n\n      if (text) {\n        formattedString += text.toString();\n      } else {\n        // Create a raw replacement string based on the conversion\n        // character and specifier\n        var replacement = replaceToken(conversionCharacter, loggingEvent, specifier);\n        formattedString += truncateAndPad(replacement, truncation, padding);\n      }\n\n      searchString = searchString.substr(result.index + result[0].length);\n    }\n\n    return formattedString;\n  };\n}\n\nvar layoutMakers = {\n  messagePassThrough: function messagePassThrough() {\n    return messagePassThroughLayout;\n  },\n  basic: function basic() {\n    return basicLayout;\n  },\n  colored: function colored() {\n    return colouredLayout;\n  },\n  coloured: function coloured() {\n    return colouredLayout;\n  },\n  pattern: function pattern(config) {\n    return patternLayout(config && config.pattern, config && config.tokens);\n  },\n  dummy: function dummy() {\n    return dummyLayout;\n  }\n};\nmodule.exports = {\n  basicLayout: basicLayout,\n  messagePassThroughLayout: messagePassThroughLayout,\n  patternLayout: patternLayout,\n  colouredLayout: colouredLayout,\n  coloredLayout: colouredLayout,\n  dummyLayout: dummyLayout,\n  addLayout: function addLayout(name, serializerGenerator) {\n    layoutMakers[name] = serializerGenerator;\n  },\n  layout: function layout(name, config) {\n    return layoutMakers[name] && layoutMakers[name](config);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}