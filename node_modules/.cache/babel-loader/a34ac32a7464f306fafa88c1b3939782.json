{"ast":null,"code":"var _classCallCheck = require(\"D:\\\\Users\\\\c05917\\\\Desktop\\\\redux\\\\chrome-api\\\\chrome\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\Users\\\\c05917\\\\Desktop\\\\redux\\\\chrome-api\\\\chrome\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar flatted = require('flatted');\n\nvar levels = require('./levels');\n/**\n * @name LoggingEvent\n * @namespace Log4js\n */\n\n\nvar LoggingEvent =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  /**\n   * Models a logging event.\n   * @constructor\n   * @param {String} categoryName name of category\n   * @param {Log4js.Level} level level of message\n   * @param {Array} data objects to log\n   * @author Seth Chisamore\n   */\n  function LoggingEvent(categoryName, level, data, context) {\n    _classCallCheck(this, LoggingEvent);\n\n    this.startTime = new Date();\n    this.categoryName = categoryName;\n    this.data = data;\n    this.level = level;\n    this.context = Object.assign({}, context);\n    this.pid = process.pid;\n  }\n\n  _createClass(LoggingEvent, [{\n    key: \"serialise\",\n    value: function serialise() {\n      var logData = this.data.map(function (e) {\n        // JSON.stringify(new Error('test')) returns {}, which is not really useful for us.\n        // The following allows us to serialize errors correctly.\n        if (e && e.message && e.stack) {\n          e = Object.assign({\n            message: e.message,\n            stack: e.stack\n          }, e);\n        }\n\n        return e;\n      });\n      this.data = logData;\n      return flatted.stringify(this);\n    }\n  }], [{\n    key: \"deserialise\",\n    value: function deserialise(serialised) {\n      var event;\n\n      try {\n        var rehydratedEvent = flatted.parse(serialised);\n        rehydratedEvent.data = rehydratedEvent.data.map(function (e) {\n          if (e && e.message && e.stack) {\n            var fakeError = new Error(e);\n            Object.keys(e).forEach(function (key) {\n              fakeError[key] = e[key];\n            });\n            e = fakeError;\n          }\n\n          return e;\n        });\n        event = new LoggingEvent(rehydratedEvent.categoryName, levels.getLevel(rehydratedEvent.level.levelStr), rehydratedEvent.data, rehydratedEvent.context);\n        event.startTime = new Date(rehydratedEvent.startTime);\n        event.pid = rehydratedEvent.pid;\n        event.cluster = rehydratedEvent.cluster;\n      } catch (e) {\n        event = new LoggingEvent('log4js', levels.ERROR, ['Unable to parse log:', serialised, 'because: ', e]);\n      }\n\n      return event;\n    }\n  }]);\n\n  return LoggingEvent;\n}();\n\nmodule.exports = LoggingEvent;","map":null,"metadata":{},"sourceType":"script"}