{"ast":null,"code":"var _classCallCheck = require(\"D:\\\\Users\\\\c05917\\\\Desktop\\\\redux\\\\chrome-api\\\\chrome\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\Users\\\\c05917\\\\Desktop\\\\redux\\\\chrome-api\\\\chrome\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"D:\\\\Users\\\\c05917\\\\Desktop\\\\redux\\\\chrome-api\\\\chrome\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"D:\\\\Users\\\\c05917\\\\Desktop\\\\redux\\\\chrome-api\\\\chrome\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"D:\\\\Users\\\\c05917\\\\Desktop\\\\redux\\\\chrome-api\\\\chrome\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar debug = require('debug')('streamroller:RollingFileWriteStream');\n\nvar _ = require('lodash');\n\nvar async = require('async');\n\nvar fs = require('fs-extra');\n\nvar zlib = require('zlib');\n\nvar path = require('path');\n\nvar newNow = require('./now');\n\nvar format = require('date-format');\n\nvar _require = require('stream'),\n    Writable = _require.Writable;\n\nvar FILENAME_SEP = '.';\nvar ZIP_EXT = '.gz';\n\nvar moveAndMaybeCompressFile = function moveAndMaybeCompressFile(sourceFilePath, targetFilePath, needCompress, done) {\n  if (sourceFilePath === targetFilePath) {\n    debug(\"moveAndMaybeCompressFile: source and target are the same, not doing anything\");\n    return done();\n  }\n\n  fs.access(sourceFilePath, fs.constants.W_OK | fs.constants.R_OK, function (e) {\n    if (e) {\n      debug(\"moveAndMaybeCompressFile: source file path does not exist. not moving. sourceFilePath=\".concat(sourceFilePath));\n      return done();\n    }\n\n    debug(\"moveAndMaybeCompressFile: moving file from \".concat(sourceFilePath, \" to \").concat(targetFilePath, \" \").concat(needCompress ? 'with' : 'without', \" compress\"));\n\n    if (needCompress) {\n      fs.createReadStream(sourceFilePath).pipe(zlib.createGzip()).pipe(fs.createWriteStream(targetFilePath)).on('finish', function () {\n        debug(\"moveAndMaybeCompressFile: finished compressing \".concat(targetFilePath, \", deleting \").concat(sourceFilePath));\n        fs.unlink(sourceFilePath, done);\n      });\n    } else {\n      debug(\"moveAndMaybeCompressFile: deleting file=\".concat(targetFilePath, \", renaming \").concat(sourceFilePath, \" to \").concat(targetFilePath));\n      fs.unlink(targetFilePath, function () {\n        fs.rename(sourceFilePath, targetFilePath, done);\n      });\n    }\n  });\n};\n/**\n * RollingFileWriteStream is mainly used when writing to a file rolling by date or size.\n * RollingFileWriteStream inhebites from stream.Writable\n */\n\n\nvar RollingFileWriteStream =\n/*#__PURE__*/\nfunction (_Writable) {\n  \"use strict\";\n\n  _inherits(RollingFileWriteStream, _Writable);\n\n  /**\n   * Create a RollingFileWriteStream\n   * @constructor\n   * @param {string} filePath - The file path to write.\n   * @param {object} options - The extra options\n   * @param {number} options.numToKeep - The max numbers of files to keep.\n   * @param {number} options.maxSize - The maxSize one file can reach. Unit is Byte.\n   *                                   This should be more than 1024. The default is Number.MAX_SAFE_INTEGER.\n   * @param {string} options.mode - The mode of the files. The default is '0644'. Refer to stream.writable for more.\n   * @param {string} options.flags - The default is 'a'. Refer to stream.flags for more.\n   * @param {boolean} options.compress - Whether to compress backup files.\n   * @param {boolean} options.keepFileExt - Whether to keep the file extension.\n   * @param {string} options.pattern - The date string pattern in the file name.\n   * @param {boolean} options.alwaysIncludePattern - Whether to add date to the name of the first file.\n   */\n  function RollingFileWriteStream(filePath, options) {\n    var _this;\n\n    _classCallCheck(this, RollingFileWriteStream);\n\n    debug(\"creating RollingFileWriteStream. path=\".concat(filePath));\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RollingFileWriteStream).call(this, options));\n    _this.options = _this._parseOption(options);\n    _this.fileObject = path.parse(filePath);\n\n    if (_this.fileObject.dir === '') {\n      _this.fileObject = path.parse(path.join(process.cwd(), filePath));\n    }\n\n    _this.justTheFile = _this._formatFileName({\n      isHotFile: true\n    });\n    _this.filename = path.join(_this.fileObject.dir, _this.justTheFile);\n    _this.state = {\n      currentDate: newNow(),\n      currentIndex: 0,\n      currentSize: 0\n    };\n    debug(\"create new file with no hot file. name=\".concat(_this.justTheFile, \", state=\").concat(JSON.stringify(_this.state)));\n\n    _this._renewWriteStream();\n\n    return _this;\n  }\n\n  _createClass(RollingFileWriteStream, [{\n    key: \"_parseOption\",\n    value: function _parseOption(rawOptions) {\n      var defaultOptions = {\n        maxSize: Number.MAX_SAFE_INTEGER,\n        numToKeep: Number.MAX_SAFE_INTEGER,\n        encoding: 'utf8',\n        mode: parseInt('0644', 8),\n        flags: 'a',\n        compress: false,\n        keepFileExt: false,\n        alwaysIncludePattern: false\n      };\n\n      var options = _.defaults({}, rawOptions, defaultOptions);\n\n      if (options.maxSize <= 0) {\n        throw new Error(\"options.maxSize (\".concat(options.maxSize, \") should be > 0\"));\n      }\n\n      if (options.numToKeep < 1) {\n        throw new Error(\"options.numToKeep (\".concat(options.numToKeep, \") should be > 0\"));\n      }\n\n      debug(\"creating stream with option=\".concat(JSON.stringify(options)));\n      return options;\n    }\n  }, {\n    key: \"_shouldRoll\",\n    value: function _shouldRoll(callback) {\n      debug(\"in _shouldRoll, pattern = \".concat(this.options.pattern, \", currentDate = \").concat(this.state.currentDate, \", now = \").concat(newNow()));\n\n      if (this.options.pattern && format(this.options.pattern, this.state.currentDate) !== format(this.options.pattern, newNow())) {\n        this._roll({\n          isNextPeriod: true\n        }, callback);\n\n        return;\n      }\n\n      debug(\"in _shouldRoll, currentSize = \".concat(this.state.currentSize, \", maxSize = \").concat(this.options.maxSize));\n\n      if (this.state.currentSize >= this.options.maxSize) {\n        this._roll({\n          isNextPeriod: false\n        }, callback);\n\n        return;\n      }\n\n      callback();\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, encoding, callback) {\n      var _this2 = this;\n\n      this._shouldRoll(function () {\n        debug(\"writing chunk. \" + \"file=\".concat(_this2.currentFileStream.path, \" \") + \"state=\".concat(JSON.stringify(_this2.state), \" \") + \"chunk=\".concat(chunk));\n\n        _this2.currentFileStream.write(chunk, encoding, function (e) {\n          _this2.state.currentSize += chunk.length;\n          callback(e);\n        });\n      });\n    } // Sorted from the oldest to the latest\n\n  }, {\n    key: \"_getExistingFiles\",\n    value: function _getExistingFiles(cb) {\n      var _this3 = this;\n\n      fs.readdir(this.fileObject.dir, function (e, files) {\n        debug(\"_getExistingFiles: files=\".concat(files));\n\n        var existingFileDetails = _.compact(_.map(files, function (n) {\n          var parseResult = _this3._parseFileName(n);\n\n          debug(\"_getExistingFiles: parsed \".concat(n, \" as \").concat(parseResult));\n\n          if (!parseResult) {\n            return;\n          }\n\n          return _.assign({\n            fileName: n\n          }, parseResult);\n        }));\n\n        cb(null, _.sortBy(existingFileDetails, function (n) {\n          return (n.date ? n.date.valueOf() : newNow().valueOf()) - n.index;\n        }));\n      });\n    } // need file name instead of file abs path.\n\n  }, {\n    key: \"_parseFileName\",\n    value: function _parseFileName(fileName) {\n      var isCompressed = false;\n\n      if (fileName.endsWith(ZIP_EXT)) {\n        fileName = fileName.slice(0, -1 * ZIP_EXT.length);\n        isCompressed = true;\n      }\n\n      var metaStr;\n\n      if (this.options.keepFileExt) {\n        var prefix = this.fileObject.name + FILENAME_SEP;\n        var suffix = this.fileObject.ext;\n\n        if (!fileName.startsWith(prefix) || !fileName.endsWith(suffix)) {\n          return;\n        }\n\n        metaStr = fileName.slice(prefix.length, -1 * suffix.length);\n        debug(\"metaStr=\".concat(metaStr, \", fileName=\").concat(fileName, \", prefix=\").concat(prefix, \", suffix=\").concat(suffix));\n      } else {\n        var _prefix = this.fileObject.base;\n\n        if (!fileName.startsWith(_prefix)) {\n          return;\n        }\n\n        metaStr = fileName.slice(_prefix.length);\n        debug(\"metaStr=\".concat(metaStr, \", fileName=\").concat(fileName, \", prefix=\").concat(_prefix));\n      }\n\n      if (!metaStr) {\n        return {\n          index: 0,\n          isCompressed: isCompressed\n        };\n      }\n\n      if (this.options.pattern) {\n        var items = _.split(metaStr, FILENAME_SEP);\n\n        var indexStr = items[items.length - 1];\n        debug('items: ', items, ', indexStr: ', indexStr);\n\n        if (indexStr !== undefined && indexStr.match(/^\\d+$/)) {\n          var dateStr = metaStr.slice(0, -1 * (indexStr.length + 1));\n          debug(\"dateStr is \".concat(dateStr));\n          return {\n            index: parseInt(indexStr, 10),\n            date: format.parse(this.options.pattern, dateStr),\n            isCompressed: isCompressed\n          };\n        } else {\n          debug(\"metaStr is \".concat(metaStr));\n          return {\n            index: 0,\n            date: format.parse(this.options.pattern, metaStr),\n            isCompressed: isCompressed\n          };\n        }\n      } else {\n        if (metaStr.match(/^\\d+$/)) {\n          return {\n            index: parseInt(metaStr, 10),\n            isCompressed: isCompressed\n          };\n        }\n      }\n\n      return;\n    }\n  }, {\n    key: \"_formatFileName\",\n    value: function _formatFileName(_ref) {\n      var date = _ref.date,\n          index = _ref.index,\n          isHotFile = _ref.isHotFile;\n      debug(\"_formatFileName: date=\".concat(date, \", index=\").concat(index, \", isHotFile=\").concat(isHotFile));\n      var dateOpt = date || _.get(this, 'state.currentDate') || newNow();\n      var dateStr = format(this.options.pattern, dateOpt);\n\n      var indexOpt = index || _.get(this, 'state.currentIndex');\n\n      var oriFileName = this.fileObject.base;\n\n      if (isHotFile) {\n        debug(\"_formatFileName: includePattern? \".concat(this.options.alwaysIncludePattern, \", pattern: \").concat(this.options.pattern));\n\n        if (this.options.alwaysIncludePattern && this.options.pattern) {\n          debug(\"_formatFileName: is hot file, and include pattern, so: \".concat(oriFileName + FILENAME_SEP + dateStr));\n          return this.options.keepFileExt ? this.fileObject.name + FILENAME_SEP + dateStr + this.fileObject.ext : oriFileName + FILENAME_SEP + dateStr;\n        }\n\n        debug(\"_formatFileName: is hot file so, filename: \".concat(oriFileName));\n        return oriFileName;\n      }\n\n      var fileNameExtraItems = [];\n\n      if (this.options.pattern) {\n        fileNameExtraItems.push(dateStr);\n      }\n\n      if (indexOpt && this.options.maxSize < Number.MAX_SAFE_INTEGER) {\n        fileNameExtraItems.push(indexOpt);\n      }\n\n      var fileName;\n\n      if (this.options.keepFileExt) {\n        var baseFileName = this.fileObject.name + FILENAME_SEP + fileNameExtraItems.join(FILENAME_SEP);\n        fileName = baseFileName + this.fileObject.ext;\n      } else {\n        fileName = oriFileName + FILENAME_SEP + fileNameExtraItems.join(FILENAME_SEP);\n      }\n\n      if (this.options.compress) {\n        fileName += ZIP_EXT;\n      }\n\n      debug(\"_formatFileName: \".concat(fileName));\n      return fileName;\n    }\n  }, {\n    key: \"_moveOldFiles\",\n    value: function _moveOldFiles(isNextPeriod, cb) {\n      var _this4 = this;\n\n      var currentFilePath = this.currentFileStream.path;\n      debug(\"currentIndex = \".concat(this.state.currentIndex, \", numToKeep = \").concat(this.options.numToKeep));\n\n      var totalFilesToMove = _.min([this.state.currentIndex, this.options.numToKeep - 1]);\n\n      var filesToMove = [];\n\n      for (var i = totalFilesToMove; i >= 0; i--) {\n        debug(\"i = \".concat(i));\n        var sourceFilePath = i === 0 ? currentFilePath : path.format({\n          dir: this.fileObject.dir,\n          base: this._formatFileName({\n            date: this.state.currentDate,\n            index: i\n          })\n        });\n        var targetFilePath = i === 0 && isNextPeriod ? path.format({\n          dir: this.fileObject.dir,\n          base: this._formatFileName({\n            date: this.state.currentDate,\n            index: 1\n          })\n        }) : path.format({\n          dir: this.fileObject.dir,\n          base: this._formatFileName({\n            date: this.state.currentDate,\n            index: i + 1\n          })\n        });\n        filesToMove.push({\n          sourceFilePath: sourceFilePath,\n          targetFilePath: targetFilePath\n        });\n      }\n\n      async.eachOfSeries(filesToMove, function (files, idx, cb1) {\n        debug(\"src=\".concat(files.sourceFilePath, \", tgt=\").concat(files.sourceFilePath, \", idx=\").concat(idx, \", pos=\").concat(filesToMove.length - 1 - idx));\n        moveAndMaybeCompressFile(files.sourceFilePath, files.targetFilePath, _this4.options.compress && filesToMove.length - 1 - idx === 0, cb1);\n      }, function () {\n        if (isNextPeriod) {\n          _this4.state.currentSize = 0;\n          _this4.state.currentIndex = 0;\n          _this4.state.currentDate = newNow();\n          debug(\"rolling for next period. state=\".concat(JSON.stringify(_this4.state)));\n        } else {\n          _this4.state.currentSize = 0;\n          _this4.state.currentIndex += 1;\n          debug(\"rolling during the same period. state=\".concat(JSON.stringify(_this4.state)));\n        }\n\n        _this4._renewWriteStream(); // wait for the file to be open before cleaning up old ones,\n        // otherwise the daysToKeep calculations can be off\n\n\n        _this4.currentFileStream.write('', 'utf8', function () {\n          return _this4._clean(cb);\n        });\n      });\n    }\n  }, {\n    key: \"_roll\",\n    value: function _roll(_ref2, cb) {\n      var _this5 = this;\n\n      var isNextPeriod = _ref2.isNextPeriod;\n      debug(\"rolling, isNextPeriod ? \".concat(isNextPeriod));\n      debug(\"_roll: closing the current stream\");\n      this.currentFileStream.end('', this.options.encoding, function () {\n        _this5._moveOldFiles(isNextPeriod, cb);\n      });\n    }\n  }, {\n    key: \"_renewWriteStream\",\n    value: function _renewWriteStream() {\n      var _this6 = this;\n\n      fs.ensureDirSync(this.fileObject.dir);\n      this.justTheFile = this._formatFileName({\n        date: this.state.currentDate,\n        index: this.state.index,\n        isHotFile: true\n      });\n      var filePath = path.format({\n        dir: this.fileObject.dir,\n        base: this.justTheFile\n      });\n\n      var ops = _.pick(this.options, ['flags', 'encoding', 'mode']);\n\n      this.currentFileStream = fs.createWriteStream(filePath, ops);\n      this.currentFileStream.on('error', function (e) {\n        _this6.emit('error', e);\n      });\n    }\n  }, {\n    key: \"_clean\",\n    value: function _clean(cb) {\n      var _this7 = this;\n\n      this._getExistingFiles(function (e, existingFileDetails) {\n        debug(\"numToKeep = \".concat(_this7.options.numToKeep, \", existingFiles = \").concat(existingFileDetails.length));\n        debug('existing files are: ', existingFileDetails);\n\n        if (existingFileDetails.length > _this7.options.numToKeep) {\n          var fileNamesToRemove = _.slice(existingFileDetails.map(function (f) {\n            return f.fileName;\n          }), 0, existingFileDetails.length - _this7.options.numToKeep - 1);\n\n          _this7._deleteFiles(fileNamesToRemove, function () {\n            _this7.state.currentIndex = Math.min(_this7.state.currentIndex, _this7.options.numToKeep - 1);\n            cb();\n          });\n\n          return;\n        }\n\n        cb();\n      });\n    }\n  }, {\n    key: \"_deleteFiles\",\n    value: function _deleteFiles(fileNames, done) {\n      var _this8 = this;\n\n      debug(\"files to delete: \".concat(fileNames));\n      async.each(_.map(fileNames, function (f) {\n        return path.format({\n          dir: _this8.fileObject.dir,\n          base: f\n        });\n      }), fs.unlink, done);\n      return;\n    }\n  }]);\n\n  return RollingFileWriteStream;\n}(Writable);\n\nmodule.exports = RollingFileWriteStream;","map":null,"metadata":{},"sourceType":"script"}